<!DOCTYPE html>
<html lang="en">
<head>
    <title>OVVR</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

<!-- Online libraries and dependencies -->
<script src='https://kaboudian.github.io/abubujs/libs/Abubu.latest.js'
	    type='text/javascript'></script>
<script 
src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/ace.js'  
type="text/javascript" charset="utf-8">
</script>
<script 
    src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/mode-glsl.js'>
</script>
<script 
    src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/theme-tomorrow.js'>
</script>
<script
    src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/keybinding-vim.js'>
</script>
<script 
    src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js">
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>

<style>

/* unvisited link */
a:link {
    	color: blue;
}

/* visited link */
a:visited {
    	color: blue;
}

/* mouse over link */
a:hover {
    	color: hotpink;
}

/* selected link */
a:active {
    	color: blue;
}
/*
li{
    	margin : 10px 6px ;
} */

body {
	counter-reset: h1;
}


h1{
        max-width: 1024px ;
	text-align:left;
	color: white;
       	background-color: #00254c;
       	padding-left: 20px ;
       	padding-top: 10px ;
       	padding-bottom: 10px ;
       	border-radius: 10px;
}

h2 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #e5e5e5 ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;

    	border-radius: 10px;
}

h3 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #f0f0f0 ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;
    	border-radius: 10px;
}

h4 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #fafafa ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;
    	border-radius: 10px;
}

p{
    max-width : 700px  ;
    padding-left: 10px ;
}
canvas.clickable:hover{
    cursor:pointer ;
    cursor:hand ;
}

.footer{
    position : fixed ; 
    max-width: 1024px ;
    border-radius:10px ;
    left : 0px ;
    width : 100% ;
    background-color: #fafafa;
    color:black ;
    bottom: 0px ;
    text-align : left ;
    font: 'italic 12pt Times' ;
}


div.relative {
  position: relative;
  height: 512px;
  border: 1px solid black;
  width:100% ;
} 

div.editor {
  position : absolute;
  top: 0px;
  right: 0;
  bottom: 0;
  left: 0;
  width:100%;
}
#loading { 
    position : fixed ;
    bottom : 20px ;
    left : 10px ;
}
#loadProgress {
    width : 300px ;
    background-color: #ddd ;
}
#loadBar {
    width : 0% ;
    height : 20px ;
    background-color: #4caf50 ;
    border-radius: 3px ;
}

</style>


</head>
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- body of the html page                                             -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<body>
    <h1>OVVR Ventricular Model</h1>
    
    <div id='chooser'>
        <h2>Select the JSON file containing the structure</h2>
        <p style='color:red'>Before you can proceed, you need to choose the structural
        file!</p>
       <input type='file' id='json_structure' accept='.json, .JSON'></input>
    </div> 
    <table>
 
        </tr>
        <tr>
            <td>
                <canvas id=canvas_1 width=512 height=512>
                    Your browser doesn't support HTML5.0
                </canvas>
            </td>
            <td>
                <canvas id=canvas_2 width=512 height=512>
                    Your browser doesn't support HTML5.0
                </canvas>
            </td>
        </tr>
    </table>
<div class='loaded'>
    <h3>Instructions for modifiable sections.</h3>
<p>You can edit the source code for a number of the modeling shaders by accessing the <b>Edit/Save/Load Source Code</b> menu of the GUI. As soon as the shader is edited, the program automatically starts using the updated version of the code.</p>

<p>Notice that GLSL does not allow for mixing of data types. So, floats
and integers cannot be mixed unless directly type casted.</p>

    <div class='relative' id='editorSection' style='display:none'>
        <h2>Source code editor</h2>
        <div class='editor' id='editor'></div>
    </div>

</div>   
    
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- All shaders included here (codes written in GLSL)                 -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- ***************************************************************** -->
<script id='directionator' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * directionator.frag : find North, South, East, West, Up and Down
 * dirction indices 
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Wed 03 May 2023 10:40:03 (EDT)
 * PLACE        : Maryland, USA.
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )


/*-------------------------------------------------------------------------
 * interfacial variables
 *-------------------------------------------------------------------------
 */
in vec2 cc ;

uniform usampler2D fullTexelIndex, compressedTexelIndex ;
uniform int mx, my ;

/*------------------------------------------------------------------------
 * output colors
 *------------------------------------------------------------------------
 */
layout (location = 0) out uvec4 odir0 ;
layout (location = 1) out uvec4 odir1 ;

/*========================================================================
 * getIJ: return the IJ index on the full 2d-matrix
 *========================================================================
 */
ivec2 getIJ(ivec3 idx, ivec3 size){
    int si = idx.z % mx ;
    int sj = idx.z / mx ;

    return ivec2(size.x*si + idx.x, (my-1-sj)*size.y + idx.y) ;
}

/*========================================================================
 * getIdx: get the 3d index from the IJ indices
 *========================================================================
 */
ivec3 getIdx( ivec2 IJ, ivec3 size ){
    int si = IJ.x / size.x ;
    int sj = (my - 1) - (IJ.y/size.y) ;

    return ivec3( IJ.x % size.x, IJ.y % size.y , mx*sj + si ) ;
}

/*========================================================================
 * macros 
 *========================================================================
 */
#define isInBounds( v )     (all(greaterThanEqual(v,ivec3(0))) && \
        all(lessThan(v,size)))

#define texelInDomain(I)  ( texelFetch(compressedTexelIndex,(I),\
            0).a==uint(1) )
#define inDomain( v )   (texelInDomain( getIJ(v, size) )) 
#define isNotGood(v)   (!( inDomain(v) && isInBounds( v ) ))

/*========================================================================
 * getPackedIndex: get packed index of the point by applying the zero-flux
 * condition.
 *========================================================================
 */
uint getPackedIndex( ivec3 C, ivec3 D, ivec3 size ){
    ivec3 checkPoint = C+D ;
    
    if ( isNotGood(checkPoint) ){ /* if that direction is not good move in
                                     the opposite direction */
        checkPoint = C-D ;
        if ( isNotGood( checkPoint ) ){ /* if the opposite direction is
                                           not good either, use the
                                           central point coordinate */
            checkPoint = C ;
        }
    }
    uvec2 targetIndex = texelFetch(
            compressedTexelIndex,
            getIJ(checkPoint,size),
            0 ).xy ;
    return pack(targetIndex.x,targetIndex.y) ;  
}

/*========================================================================
 * main
 *========================================================================
 */
void main(){
    // get the sizes of the compressed and the full domain ...............
    ivec2 compSize = textureSize(fullTexelIndex,        0 ) ;
    ivec2 fullSize = textureSize(compressedTexelIndex,  0 ) ;

    // calculate the resolution of the full domain .......................
    ivec3 size = ivec3( fullSize.x/mx , fullSize.y/my, mx*my ) ;

    // get the textel position and full texel index ......................
    ivec2 texelPos = ivec2( cc*vec2(compSize) ) ; 
    ivec4 fullTexelIndex = 
        ivec4( texelFetch(  fullTexelIndex, texelPos, 0) ) ;

    // if the texel is extra, just leave .................................
    if ( fullTexelIndex.a != 1 ){
        return ;
    }
    
    // 3-dimentional index of the of texel ...............................
    ivec3 cidx = getIdx( fullTexelIndex.xy , size ) ;

    // diretionional vectors .............................................
    ivec3 ii = ivec3(1,0,0) ;
    ivec3 jj = ivec3(0,1,0) ;
    ivec3 kk = ivec3(0,0,1) ;

    // calculating the packed indices of the each compute point ..........
    uvec4 dir0 , dir1 ;
   
    NORTH = getPackedIndex( cidx, jj, size) ; // north direction
    SOUTH = getPackedIndex( cidx,-jj, size) ; // south direction
    EAST  = getPackedIndex( cidx, ii, size) ; // east  direction
    WEST  = getPackedIndex( cidx,-ii, size) ; // west  direction

    UP    = getPackedIndex( cidx, kk, size) ; // up   direction
    DOWN  = getPackedIndex( cidx,-kk, size) ; // down direction

    // outputing the calculated points ...................................
    odir0 = uvec4(dir0) ;
    odir1 = uvec4(dir1) ;

    return ;
}
</script><!-- end of directionator shader's source code -->

<!-- ***************************************************************** -->
<script id='init1' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * init1.frag   : initialize color-set 0 to 3   
 * 
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Wed 03 May 2023 11:57:09 (EDT)
 * PLACE        : Maryland, USA.
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */

precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


// interface variables ...................................................
in vec2 cc  ;

// variable macros .......................................................
#define aCaMK       color0.r
#define iCaMKfast   color0.g
#define iCaMKslow   color0.b
#define d           color0.a

#define ffast       color1.r
#define fslow       color1.g
#define fCafast     color1.b 
#define fCaslow     color1.a

#define jCa         color2.r
#define fCaMKfast   color2.g
#define fCaCaMKfast color2.b
#define n           color2.a

#define xrfast      color3.r
#define xrslow      color3.g
#define xs1         color3.b
#define xs2         color3.b

#define vlt         color4.r
#define V           color4.r
#define v           color4.g
#define xK1         color4.b
#define CaMKtrap    color4.a
#define CaMKt       CaMKtrap

#define Cansr       color5.r
#define Cajsr       color5.g
#define Cass        color5.b
#define Cai         color5.a 

#define Kss         color6.r
#define Ki          color6.g
#define Nass        color6.b
#define Nai         color6.a

#define m           color7.r
#define hfast       color7.g
#define hslow       color7.b
#define j           color7.a

#define hCaMKslow   color8.r
#define jCaMK       color8.g
#define mL          color8.b
#define hL          color8.a

#define JrelNP      color9.r
#define hLCaMK      color9.g


#define JrelCaMK    color10.r
#define sa          color10.g
#define ifast       color10.b
#define islow       color10.a

#define tvlt        color11.r
#define time        color11.g

#define vlt_txtr    icolor4
#define vchannel r


// color outputs .........................................................
layout (location = 0) out vec4 ocolor0 ; 
layout (location = 1) out vec4 ocolor1 ; 
layout (location = 2) out vec4 ocolor2 ; 
layout (location = 3) out vec4 ocolor3 ; 

/*========================================================================
 * main body of the shader
 *========================================================================
 */
void main(){
    // color declarations ................................................
    vec4 color0, color1, color2, color3,  color4, color5, 
         color6, color7, color8, color9, color10, color11 ;

    // color initializations .............................................
    aCaMK       = 0.000515567 ;
    iCaMKfast   = 0.9999542 ;
    iCaMKslow   = 0.641861 ;
    d           = 2.43015e-9 ;

    ffast       = 1.0 ;
    fslow       = 0.910671 ;
    fCafast     = 1.0 ;
    fCaslow     = 0.99982 ;
    
    xrfast      = 8.26608e-6 ;
    xrslow      = 0.453268  ;
    xs1         = 0.270492 ;
    xs2         = 0.0001963 ;

    // output color values ...............................................
    ocolor0 = vec4(color0) ;
    ocolor1 = vec4(color1) ;
    ocolor2 = vec4(color2) ;
    ocolor3 = vec4(color3) ;

    return ;
}
</script><!-- end of init1 shader's source code -->

<!-- ***************************************************************** -->
<script id='init2' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * init2.frag   : initialize color-set 4 to 11   
 * 
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Wed 03 May 2023 11:58:01 (EDT)
 * PLACE        : Maryland, USA.
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */

precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


// interface variables ...................................................
in vec2 cc ;

// variable macros .......................................................
#define aCaMK       color0.r
#define iCaMKfast   color0.g
#define iCaMKslow   color0.b
#define d           color0.a

#define ffast       color1.r
#define fslow       color1.g
#define fCafast     color1.b 
#define fCaslow     color1.a

#define jCa         color2.r
#define fCaMKfast   color2.g
#define fCaCaMKfast color2.b
#define n           color2.a

#define xrfast      color3.r
#define xrslow      color3.g
#define xs1         color3.b
#define xs2         color3.b

#define vlt         color4.r
#define V           color4.r
#define v           color4.g
#define xK1         color4.b
#define CaMKtrap    color4.a
#define CaMKt       CaMKtrap

#define Cansr       color5.r
#define Cajsr       color5.g
#define Cass        color5.b
#define Cai         color5.a 

#define Kss         color6.r
#define Ki          color6.g
#define Nass        color6.b
#define Nai         color6.a

#define m           color7.r
#define hfast       color7.g
#define hslow       color7.b
#define j           color7.a

#define hCaMKslow   color8.r
#define jCaMK       color8.g
#define mL          color8.b
#define hL          color8.a

#define JrelNP      color9.r
#define hLCaMK      color9.g


#define JrelCaMK    color10.r
#define sa          color10.g
#define ifast       color10.b
#define islow       color10.a

#define tvlt        color11.r
#define time        color11.g

#define vlt_txtr    icolor4
#define vchannel r


// color outputs .........................................................
layout (location = 0) out vec4 ocolor4 ; 
layout (location = 1) out vec4 ocolor5 ; 
layout (location = 2) out vec4 ocolor6 ; 
layout (location = 3) out vec4 ocolor7 ; 
layout (location = 4) out vec4 ocolor8 ; 
layout (location = 5) out vec4 ocolor9 ; 
layout (location = 6) out vec4 ocolor10; 

/*========================================================================
 * main body of the shader
 *========================================================================
 */
void main(){
    // color declarations ................................................
    vec4 color0, color1, color2, color3,  color4, color5, 
         color6, color7, color8, color9,  color10 ;

    // color initializations .............................................
    m           = 0.0074621 ;
    hfast       = 0.692591  ;
    hslow       = 0.692574  ;
    j           = 0.692477  ;

    hCaMKslow   = 0.448501    ;   
    jCaMK       = 0.692413    ;   
    mL          = 0.000194015 ;
    hL          = 0.496116    ;

    JrelNP      = 2.53943e-5  ;
    hLCaMK      = 0.265885   ;

    JrelCaMK    = 3.17262e-7 ;
    sa          = 0.00101185 ;
    ifast       = 0.999542   ;
    islow       = 0.589579   ;

    vlt         = -87.84 ;
    v           = hslow ;

    Cansr       = 1.61 ;  
    Cajsr       = 1.56 ;   
    Cass        = 8.43e-5 ;
    Cai         = 8.54e-5;

    Kss         = 143.79 ; 
    Ki          = 143.79 ;
    Nass        = 7.23   ; 
    Nai         = 7.23   ;

    // output color values ...............................................
    ocolor4  = vec4( color4  ) ;
    ocolor5  = vec4( color5  ) ;
    ocolor6  = vec4( color6  ) ;
    ocolor7  = vec4( color7  ) ;
    ocolor8  = vec4( color8  ) ;
    ocolor9  = vec4( color9  ) ;
    ocolor10 = vec4( color10 ) ;

    return ;
}
</script><!-- end of init2 shader's source code -->

<!-- ***************************************************************** -->
<script id='comp1' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * comp1.frag   : march color0 to 3 for one time-step
 * 
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Wed 03 May 2023 11:34:48 (EDT)
 * PLACE        : Maryland, USA.
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


// interface variables ...................................................
in vec2 cc  ;

// uniforms and useful macros ............................................

/* uniform samplers of state variables  */
uniform sampler2D   
        icolor0, icolor1, icolor2, icolor3, icolor4,  icolor5, 
        icolor6, icolor7, icolor8, icolor9, icolor10 ;

uniform float   dt ;        /* time step                */
uniform float   lx ;        /* domain size in x,y-dir   */
uniform float   diffCoef ;  /* diffusion coeficient     */
uniform float   C_m ;       /* membrane capacitance     */
uniform int     mx, my ;    /* number of z-layers in 
                               S and T directions 
                               of the textures          */
// directional information ...............................................
uniform usampler2D  idir0 ;
uniform usampler2D  idir1 ;

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )



// coordinate of the system ..............................................
uniform sampler2D   compressed3dCrdt ;
       
uniform int         cellType ;

/* Extra-cellular concenterations       */
uniform float       Ca_o, Na_o, K_o ;

/* time factor multipliers              */
uniform float       Ct_m          ; 
uniform float       Ct_h          ; 
uniform float       Ct_j          ; 
uniform float       Ct_hCaMKslow  ; 
uniform float       Ct_hslow      ; 
uniform float       Ct_mL         ; 
uniform float       Ct_jCaMK      ; 
uniform float       Ct_hL         ; 
uniform float       Ct_hLCaMK     ; 
uniform float       Ct_a          ; 
uniform float       Ct_ifast      ; 
uniform float       Ct_islow      ; 
uniform float       Ct_aCaMK      ; 
uniform float       Ct_iCaMKfast  ; 
uniform float       Ct_iCaMKslow  ; 
uniform float       Ct_d          ; 
uniform float       Ct_ffast      ; 
uniform float       Ct_fslow      ; 
uniform float       Ct_fCafast    ; 
uniform float       Ct_fCaslow    ; 
uniform float       Ct_jCa        ; 
uniform float       Ct_fCaMKfast  ; 
uniform float       Ct_fCaCaMKfast; 
uniform float       Ct_n          ; 
uniform float       Ct_xrfast     ; 
uniform float       Ct_xrslow     ; 
uniform float       Ct_xs1        ; 
uniform float       Ct_xs2        ; 
uniform float       Ct_xk1        ; 
uniform float       Ct_relNP      ; 
uniform float       Ct_relCaMK    ; 
uniform float       Ct_tr         ; 
uniform float       Ct_diffCa     ; 
uniform float       Ct_diffNa     ; 
uniform float       Ct_diffK      ; 

/* current multipliers                  */
uniform float       C_Na        ;
uniform float       C_Nafast    ;
uniform float       C_Nalate    ;
uniform float       C_NaCa      ;
uniform float       C_to        ;
uniform float       C_CaL       ;
uniform float       C_CaNa      ;
uniform float       C_CaK       ;
uniform float       C_Kr        ;
uniform float       C_Ks        ;
uniform float       C_K1        ;
uniform float       C_NaCai     ;
uniform float       C_NaCass    ;
uniform float       C_NaKNa     ;
uniform float       C_NaKK      ;
uniform float       C_NaK       ;
uniform float       C_Nab       ;
uniform float       C_Kb        ;
uniform float       C_Cab       ;
uniform float       C_pCa       ;
uniform float       C_relNP     ;
uniform float       C_relCaMK   ;
uniform float       C_upNP      ;
uniform float       C_upCaMK    ;
uniform float       C_leak      ;
uniform float       C_up        ;
uniform float       C_tr        ;
uniform float       C_rel       ;
uniform float       C_diffCa    ;
uniform float       C_diffNa    ;
uniform float       C_diffK     ;


/* Scaling Factors                      */
uniform float       SGNalate ;  
uniform float       SGto     ;  
uniform float       SPCa     ;  
uniform float       SGKr     ;  
uniform float       SGKs     ;  
uniform float       SGK1     ;  
uniform float       SGNaCa   ;  
uniform float       SGNaK    ;  
uniform float       SGKb     ;  
uniform float       SJrel    ;  
uniform float       SJup     ;  
uniform float       SCMDN    ;


/* macros (of constants)                */
#define bt          4.75
#define arel        2.375
#define btCaMK      5.9375
#define arekCaMK    2.96875

#define i           0
#define ss          1

#define kNa1        15.0
#define kNa2        5.0
#define kNa3        88.12
#define kasymm      12.5
#define omegaNa     6.0e4
#define omegaCa     6.0e4
#define omegaNaCa   5.0e3
#define kCaon       1.5e6
#define kCaoff      5.0e3
#define KmCaAct     150.e-6

#define Nao         Na_o
#define Cao         Ca_o
#define Ko          K_o

#define qNa         0.5224
#define qCa         0.1670

//#define Nao         140.0
//#define Cao         1.8
//#define Ko          5.4

#define zNa         1.0
#define zCa         2.0
#define zK          1.0 

#define gKi         0.75
#define gKo         0.75
#define gCai        1.0 
#define gCao        0.341

#define GNaCa       0.0008
#define GNa         14.838
#define Gto         0.02

#define gNai        0.75
#define gNao        0.75

#define PNab        3.75e-10
#define PCab        2.5e-8
#define GpCa        0.0005
#define PRNaK       0.01833

#define arelCaMK    2.96875
#define byCaMK      5.9375

#define ACaMK       0.05
#define bCaMK       0.00068
#define CaMK0       0.05
#define KmCaM       0.0015
#define KmCaMK      0.15
#define CaMKo       0.05

#define GNafast     75.0
#define GNalate     0.0075

#define CSQN        10.
#define KmCSQN      0.8
#define CMDNI       0.05
#define KmCMDN      0.00238
#define TRPN        0.07
#define KmTRPN      0.0005
#define tdiffCaCnst 0.2

#define Acap        1.534e-4
#define Ageo        0.767e-4
#define vcell       38.0e-6
#define vss         0.76e-6
#define vmyo        25.84e-6
#define vnsr        2.098e-6
#define vjsr        0.182e-6

#define BSR         0.047
#define KmBSR       0.00087
#define BSL         1.124
#define KmBSL       0.0087


#define F           96486.7
#define R           8314.3
#define T           310.

#define kp1         949.5
#define kp2         687.2
#define kp3         1899.
#define kp4         639.0
#define km1         182.4
#define km2         39.4
#define km3         79300.0
#define km4         40.0
#define KKi         0.5
#define KKo         0.3582
#define MgADP       0.05
#define MgATP       9.8
#define KMgATP      1.698e-7
#define H           1.e-7
#define SP          4.2
#define KHP         1.698e-7
#define KNaP        224.0
#define KKP         292.0

#define K0Nai       9.073        
#define K0Nao       27.78 
#define Delta       -0.1550 

const float rtof    = R*T/F ;
const float fort    = F/(R*T) ;

#define     EPI     1
#define     ENDO    2
#define     MID     0

/* raise a number to power 8        */
float   pow8(float x){
    return  x*x*x*x*
            x*x*x*x ;
}


// variable macros .......................................................

#define aCaMK       color0.r
#define iCaMKfast   color0.g
#define iCaMKslow   color0.b
#define d           color0.a

#define ffast       color1.r
#define fslow       color1.g
#define fCafast     color1.b 
#define fCaslow     color1.a

#define jCa         color2.r
#define fCaMKfast   color2.g
#define fCaCaMKfast color2.b
#define n           color2.a

#define xrfast      color3.r
#define xrslow      color3.g
#define xs1         color3.b
#define xs2         color3.b

#define vlt         color4.r
#define V           color4.r
#define v           color4.g
#define xK1         color4.b
#define CaMKtrap    color4.a
#define CaMKt       CaMKtrap

#define Cansr       color5.r
#define Cajsr       color5.g
#define Cass        color5.b
#define Cai         color5.a 

#define Kss         color6.r
#define Ki          color6.g
#define Nass        color6.b
#define Nai         color6.a

#define m           color7.r
#define hfast       color7.g
#define hslow       color7.b
#define j           color7.a

#define hCaMKslow   color8.r
#define jCaMK       color8.g
#define mL          color8.b
#define hL          color8.a

#define JrelNP      color9.r
#define hLCaMK      color9.g


#define JrelCaMK    color10.r
#define sa          color10.g
#define ifast       color10.b
#define islow       color10.a

#define tvlt        color11.r
#define time        color11.g

#define vlt_txtr    icolor4
#define vchannel r


// color outputs .........................................................
layout (location = 0) out vec4 ocolor0 ; 
layout (location = 1) out vec4 ocolor1 ; 
layout (location = 2) out vec4 ocolor2 ; 
layout (location = 3) out vec4 ocolor3 ; 


// Functions/macros for Rush-Larsen time integration .....................

/*========================================================================
 * RL1  : Rush Larsen 1: works with y_inf and tau_y
 *      dy/dt = (y_inf - y)/tau_y where
 *========================================================================
 */
float RL1(float yo, float y_inf, float tau_inf,float deltaT){
    return y_inf + (yo - y_inf)*exp(-deltaT/tau_inf) ; 
}

/*========================================================================
 * RL2 : Rush Larsen 2: works with a and b values 
 *      dy/dt = (y_inf - y)/tau_y where
 *      y_inf = a/(a+b)     and      tau_y = 1./(a+b)
 *========================================================================
 */
float RL2(float yo, float a, float b,float deltaT){
    float y_inf = a/(a+b) ;
    float t_inf = 1./(a+b) ;

    return RL1(yo,y_inf,t_inf,deltaT) ; 
}


/*========================================================================
 * main body of the shader
 *========================================================================
 */
void main(){
    ivec2 isize = textureSize( icolor0 , 0 ) ;
    ivec2 texelPos = ivec2(cc*vec2(isize)) ;

    // localizing variables ..............................................
    vec4 color0  = texelFetch( icolor0  , texelPos, 0) ;
    vec4 color1  = texelFetch( icolor1  , texelPos, 0) ;
    vec4 color2  = texelFetch( icolor2  , texelPos, 0) ;
    vec4 color3  = texelFetch( icolor3  , texelPos, 0) ;
    vec4 color4  = texelFetch( icolor4  , texelPos, 0) ;
    vec4 color5  = texelFetch( icolor5  , texelPos, 0) ;
    vec4 color6  = texelFetch( icolor6  , texelPos, 0) ;
    vec4 color7  = texelFetch( icolor7  , texelPos, 0) ;
    vec4 color8  = texelFetch( icolor8  , texelPos, 0) ;
    vec4 color9  = texelFetch( icolor9  , texelPos, 0) ;
    vec4 color10 = texelFetch( icolor10 , texelPos, 0) ;

    // aCaMK .............................................................
    float   aCaMKinf = 1./
            (   1. +    exp(  -(V-24.34)/14.82 )           ) ;

    float   ta       = 1.0515/
            (   1./ (   1.2089*(1.+exp(-(V-18.41)/29.38))  ) +
                3.5/(   1. + exp(  (V+100.)/29.38  )   )   ) ;

    ta *= Ct_aCaMK ;

    aCaMK = RL1( aCaMK, aCaMKinf, ta, dt ) ;

    // iCaMKfast, iCaMKslow ..............................................
    float   iCaMKinf = 1./
            (   1. + exp(   (V+43.94)/5.711    )           ) ;

    float   dCaMKdev = 1.354 + 1.0e-4/
            (   exp(           (V-167.4)/15.89     ) +
                exp(          -(V-12.23)/0.2145    )       ) ;

    float   dCaMKrec = 1.0 - 0.5/
            (   1. +    exp(   (V+70.)/20.0        )       ) ;

    float   tifast   = 4.562 + 1./
            (   0.3933*exp(-(V+100.)/100.  ) +
                0.08004*exp((V+50.0)/16.59 )               ) ;


    float   tislow   = 23.62 +
            1./( 0.001416*exp(-(V+96.52)/59.05 )
                +1.7808e-8*exp((V+114.1)/8.079 )           ) ;
    float   tiCaMKfast = tifast*dCaMKdev*dCaMKrec*Ct_iCaMKfast ;
    float   tiCaMKslow = tislow*dCaMKdev*dCaMKrec*Ct_iCaMKslow ;

    iCaMKfast = RL1( iCaMKfast, aCaMKinf, tiCaMKfast, dt ) ;
    iCaMKslow = RL1( iCaMKslow, aCaMKinf, tiCaMKslow, dt ) ;

    // d .................................................................
    float   dinf = 1./
            (   1. +    exp(   -(V+3.940)/4.230    )       ) ;

    float   td   =  0.6 + 1./
            (   exp(   -0.05*(V+6.0)               ) +
                exp(    0.09*(V+14.0)              )       ) ;
    td *= Ct_d ;
    
    d = RL1(d, dinf, td, dt ) ;

    // ffast, fslow ......................................................
    float   finf    =  1./
            (   1. + exp(      (V+19.58)/3.696     )       ) ;

    float   tffast  =  7.0 + 1./
            (   0.0045*exp(   -(V+20.0)/10.0       ) +
                0.0045*exp(    (V+20.0)/10.0       )       ) ;
    tffast *= Ct_ffast ;

    float   tfslow  = 1000.0 +
                1./(    0.000035*exp(-(V+5.0)/4.0 ) +
                        0.000035*exp( (V+5.0)/6.0 )        ) ;
    tfslow *= Ct_fslow ;

    ffast = RL1( ffast , finf, tffast, dt ) ;
    fslow = RL1( fslow , finf, tfslow, dt ) ;

    // fCafast, fCaslow ..................................................
    float   fCainf   = finf ;
    float   tfCafast = 7.0 +
                1./(    0.04*exp( -(V-4.0)/7.0)    +
                        0.04*exp(  (V-4.0)/7.0)            ) ;
    tfCafast *= Ct_fCafast ;

    float   tfCaslow = 100.0 +
                1./(    0.00012*exp( -V/3.0 ) +
                        0.00012*exp(  V/7.0 )              ) ;
    tfCaslow *= Ct_fCaslow ;
    
    fCafast = RL1( fCafast, fCainf, tfCafast, dt ) ;
    fCaslow = RL1( fCaslow, fCainf, tfCaslow, dt ) ;

    // jCa ...............................................................
    float   jCainf  =  1./
            (   1. + exp(      (V+19.58)/3.696     )       ) ;

    float   tjCa    = 75.0*Ct_jCa ;
    
    jCa = RL1( jCa, jCainf, tjCa, dt ) ;

    // fCaMKfast .........................................................
    float   fCaMKinf = jCainf ;

    float   tfCaCMfast = 7.0 + 1./
            (   0.0045*exp(   -(V+20.0)/10.0       ) +
                0.0045*exp(    (V+20.0)/10.0       )       ) ;
    tfCaCMfast *= 2.5*Ct_fCaMKfast ;

    fCaMKfast = RL1(fCaMKfast, fCaMKinf, tfCaCMfast, dt ) ;

    // fCaCaMKfast .......................................................
    float   fCaCaMKinf = jCainf ;

    float   tfCaCaMKfast = 7.0 + 1./
            (   0.0045*exp(   -(V+20.0)/10.0       ) +
                0.0045*exp(    (V+20.0)/10.0       )       ) ;
    tfCaCaMKfast *=  2.5*2.5*Ct_fCaCaMKfast ;

    tfCaCaMKfast = RL1( tfCaCaMKfast, fCaCaMKinf, tfCaCaMKfast, dt ) ; 
    
    // n .................................................................
    float Kmn  = 0.002 ; float kp2n = 1000.0 ; float km2n = jCa ;
    Cass = Cajsr ;

    float kappa     = 1. + Kmn/Cass ;
    kappa           = kappa*kappa*kappa*kappa ;

    float alpha_n   = 1.0 /( kp2n/km2n  + kappa ) ;
    float ninf      = alpha_n*kp2n/km2n ;
    float tn        = Ct_n/km2n ;
    
    n = RL1( n, ninf, tn, dt ) ;

    // xrfast, xrslow ....................................................
    float   xrinf   = 1./
            (   1.  +   exp(   -(V+8.337)/6.789    )       ) ;

    float   txrfast  = (
             12.98 + 1./
            (   0.3652*exp(     (V-31.66)/3.869    ) +
                4.123e-5*exp(  -(V-47.78)/20.38    )       )
        )*Ct_xrfast ;

    float   txrslow  = (
                1.865 + 1./
            (   0.06629*exp(    (V-34.70)/7.355    ) +
                1.128e-5*exp(   (29.74-V)/25.94    )       ) 
        ) * Ct_xrslow ;

    xrfast = RL1( xrfast, xrinf, txrfast, dt ) ;
    xrslow = RL1( xrslow, xrinf, txrslow, dt ) ;

    // xs1, xs2 ..........................................................
    float   xs1inf  = 1./
            (   1. +    exp(   -(V+11.60)/8.932    )       ) ;

    float   xs2inf  = xs1inf ;
    float   txs1    = (
             817.3 + 1./
            (   2.326e-4*exp(   (V+48.28)/17.80    ) +
                0.001292*exp(  -(V+210.0)/230.0    )       )
        ) * Ct_xs1 ;
    float   txs2    = (
             1./
            (   0.01*exp(       (V-50.0)/20.0      ) +
                0.0193*exp(    -(V+66.54)/31.      )       ) 
        ) * Ct_xs2 ;

    xs1 = RL1( xs1, xs1inf, txs1, dt ) ;
    xs2 = RL1( xs2, xs2inf, txs2, dt ) ;
    
    
    // output color values ...............................................
    ocolor0 = vec4(color0) ;
    ocolor1 = vec4(color1) ;
    ocolor2 = vec4(color2) ;
    ocolor3 = vec4(color3) ;

    return ;
}
</script><!-- end of comp1 shader's source code -->

<!-- ***************************************************************** -->
<script id='comp2' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * comp2.frag   : march color-set 4 to 11 for one time step
 * 
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Wed 03 May 2023 11:43:51 (EDT)
 * PLACE        : Maryland, USA.
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


in vec2 cc  ;

/*========================================================================
 * Comp Uniforms
 *========================================================================
 */

/* uniform samplers of state variables  */
uniform sampler2D   
        icolor0, icolor1, icolor2, icolor3, icolor4,  icolor5, 
        icolor6, icolor7, icolor8, icolor9, icolor10 ;

uniform float   dt ;        /* time step                */
uniform float   lx ;        /* domain size in x,y-dir   */
uniform float   diffCoef ;  /* diffusion coeficient     */
uniform float   C_m ;       /* membrane capacitance     */
uniform int     mx, my ;    /* number of z-layers in 
                               S and T directions 
                               of the textures          */
// directional information ...............................................
uniform usampler2D  idir0 ;
uniform usampler2D  idir1 ;

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )



// coordinate of the system ..............................................
uniform sampler2D   compressed3dCrdt ;
       
uniform int         cellType ;

/* Extra-cellular concenterations       */
uniform float       Ca_o, Na_o, K_o ;

/* time factor multipliers              */
uniform float       Ct_m          ; 
uniform float       Ct_h          ; 
uniform float       Ct_j          ; 
uniform float       Ct_hCaMKslow  ; 
uniform float       Ct_hslow      ; 
uniform float       Ct_mL         ; 
uniform float       Ct_jCaMK      ; 
uniform float       Ct_hL         ; 
uniform float       Ct_hLCaMK     ; 
uniform float       Ct_a          ; 
uniform float       Ct_ifast      ; 
uniform float       Ct_islow      ; 
uniform float       Ct_aCaMK      ; 
uniform float       Ct_iCaMKfast  ; 
uniform float       Ct_iCaMKslow  ; 
uniform float       Ct_d          ; 
uniform float       Ct_ffast      ; 
uniform float       Ct_fslow      ; 
uniform float       Ct_fCafast    ; 
uniform float       Ct_fCaslow    ; 
uniform float       Ct_jCa        ; 
uniform float       Ct_fCaMKfast  ; 
uniform float       Ct_fCaCaMKfast; 
uniform float       Ct_n          ; 
uniform float       Ct_xrfast     ; 
uniform float       Ct_xrslow     ; 
uniform float       Ct_xs1        ; 
uniform float       Ct_xs2        ; 
uniform float       Ct_xk1        ; 
uniform float       Ct_relNP      ; 
uniform float       Ct_relCaMK    ; 
uniform float       Ct_tr         ; 
uniform float       Ct_diffCa     ; 
uniform float       Ct_diffNa     ; 
uniform float       Ct_diffK      ; 

/* current multipliers                  */
uniform float       C_Na        ;
uniform float       C_Nafast    ;
uniform float       C_Nalate    ;
uniform float       C_NaCa      ;
uniform float       C_to        ;
uniform float       C_CaL       ;
uniform float       C_CaNa      ;
uniform float       C_CaK       ;
uniform float       C_Kr        ;
uniform float       C_Ks        ;
uniform float       C_K1        ;
uniform float       C_NaCai     ;
uniform float       C_NaCass    ;
uniform float       C_NaKNa     ;
uniform float       C_NaKK      ;
uniform float       C_NaK       ;
uniform float       C_Nab       ;
uniform float       C_Kb        ;
uniform float       C_Cab       ;
uniform float       C_pCa       ;
uniform float       C_relNP     ;
uniform float       C_relCaMK   ;
uniform float       C_upNP      ;
uniform float       C_upCaMK    ;
uniform float       C_leak      ;
uniform float       C_up        ;
uniform float       C_tr        ;
uniform float       C_rel       ;
uniform float       C_diffCa    ;
uniform float       C_diffNa    ;
uniform float       C_diffK     ;


/* Scaling Factors                      */
uniform float       SGNalate ;  
uniform float       SGto     ;  
uniform float       SPCa     ;  
uniform float       SGKr     ;  
uniform float       SGKs     ;  
uniform float       SGK1     ;  
uniform float       SGNaCa   ;  
uniform float       SGNaK    ;  
uniform float       SGKb     ;  
uniform float       SJrel    ;  
uniform float       SJup     ;  
uniform float       SCMDN    ;


/* macros (of constants)                */
#define bt          4.75
#define arel        2.375
#define btCaMK      5.9375
#define arekCaMK    2.96875

#define i           0
#define ss          1

#define kNa1        15.0
#define kNa2        5.0
#define kNa3        88.12
#define kasymm      12.5
#define omegaNa     6.0e4
#define omegaCa     6.0e4
#define omegaNaCa   5.0e3
#define kCaon       1.5e6
#define kCaoff      5.0e3
#define KmCaAct     150.e-6

#define Nao         Na_o
#define Cao         Ca_o
#define Ko          K_o

#define qNa         0.5224
#define qCa         0.1670

//#define Nao         140.0
//#define Cao         1.8
//#define Ko          5.4

#define zNa         1.0
#define zCa         2.0
#define zK          1.0 

#define gKi         0.75
#define gKo         0.75
#define gCai        1.0 
#define gCao        0.341

#define GNaCa       0.0008
#define GNa         14.838
#define Gto         0.02

#define gNai        0.75
#define gNao        0.75

#define PNab        3.75e-10
#define PCab        2.5e-8
#define GpCa        0.0005
#define PRNaK       0.01833

#define arelCaMK    2.96875
#define byCaMK      5.9375

#define ACaMK       0.05
#define bCaMK       0.00068
#define CaMK0       0.05
#define KmCaM       0.0015
#define KmCaMK      0.15
#define CaMKo       0.05

#define GNafast     75.0
#define GNalate     0.0075

#define CSQN        10.
#define KmCSQN      0.8
#define CMDNI       0.05
#define KmCMDN      0.00238
#define TRPN        0.07
#define KmTRPN      0.0005
#define tdiffCaCnst 0.2

#define Acap        1.534e-4
#define Ageo        0.767e-4
#define vcell       38.0e-6
#define vss         0.76e-6
#define vmyo        25.84e-6
#define vnsr        2.098e-6
#define vjsr        0.182e-6

#define BSR         0.047
#define KmBSR       0.00087
#define BSL         1.124
#define KmBSL       0.0087


#define F           96486.7
#define R           8314.3
#define T           310.

#define kp1         949.5
#define kp2         687.2
#define kp3         1899.
#define kp4         639.0
#define km1         182.4
#define km2         39.4
#define km3         79300.0
#define km4         40.0
#define KKi         0.5
#define KKo         0.3582
#define MgADP       0.05
#define MgATP       9.8
#define KMgATP      1.698e-7
#define H           1.e-7
#define SP          4.2
#define KHP         1.698e-7
#define KNaP        224.0
#define KKP         292.0

#define K0Nai       9.073        
#define K0Nao       27.78 
#define Delta       -0.1550 

const float rtof    = R*T/F ;
const float fort    = F/(R*T) ;

#define     EPI     1
#define     ENDO    2
#define     MID     0

/* raise a number to power 8        */
float   pow8(float x){
    return  x*x*x*x*
            x*x*x*x ;
}


/*========================================================================
 * Variable map
 *========================================================================
 */
#define aCaMK       color0.r
#define iCaMKfast   color0.g
#define iCaMKslow   color0.b
#define d           color0.a

#define ffast       color1.r
#define fslow       color1.g
#define fCafast     color1.b 
#define fCaslow     color1.a

#define jCa         color2.r
#define fCaMKfast   color2.g
#define fCaCaMKfast color2.b
#define n           color2.a

#define xrfast      color3.r
#define xrslow      color3.g
#define xs1         color3.b
#define xs2         color3.b

#define vlt         color4.r
#define V           color4.r
#define v           color4.g
#define xK1         color4.b
#define CaMKtrap    color4.a
#define CaMKt       CaMKtrap

#define Cansr       color5.r
#define Cajsr       color5.g
#define Cass        color5.b
#define Cai         color5.a 

#define Kss         color6.r
#define Ki          color6.g
#define Nass        color6.b
#define Nai         color6.a

#define m           color7.r
#define hfast       color7.g
#define hslow       color7.b
#define j           color7.a

#define hCaMKslow   color8.r
#define jCaMK       color8.g
#define mL          color8.b
#define hL          color8.a

#define JrelNP      color9.r
#define hLCaMK      color9.g


#define JrelCaMK    color10.r
#define sa          color10.g
#define ifast       color10.b
#define islow       color10.a

#define tvlt        color11.r
#define time        color11.g

#define vlt_txtr    icolor4
#define vchannel r


// color outputs .........................................................
layout (location = 0) out vec4 ocolor4  ; 
layout (location = 1) out vec4 ocolor5  ; 
layout (location = 2) out vec4 ocolor6  ; 
layout (location = 3) out vec4 ocolor7  ; 
layout (location = 4) out vec4 ocolor8  ; 
layout (location = 5) out vec4 ocolor9  ; 
layout (location = 6) out vec4 ocolor10 ; 


// Functions/macros for Rush-Larsen time integration .....................

/*========================================================================
 * RL1  : Rush Larsen 1: works with y_inf and tau_y
 *      dy/dt = (y_inf - y)/tau_y where
 *========================================================================
 */
float RL1(float yo, float y_inf, float tau_inf,float deltaT){
    return y_inf + (yo - y_inf)*exp(-deltaT/tau_inf) ; 
}

/*========================================================================
 * RL2 : Rush Larsen 2: works with a and b values 
 *      dy/dt = (y_inf - y)/tau_y where
 *      y_inf = a/(a+b)     and      tau_y = 1./(a+b)
 *========================================================================
 */
float RL2(float yo, float a, float b,float deltaT){
    float y_inf = a/(a+b) ;
    float t_inf = 1./(a+b) ;

    return RL1(yo,y_inf,t_inf,deltaT) ; 
}


void laplacian(sampler2D icolor, out ivec2 texelPos, out vec4 l){
    ivec2 size = textureSize(icolor, 0 ) ;
    texelPos = ivec2(cc*vec2(size)) ;
    
    // directional channels ..............................................
    uvec4 dir0  = texelFetch(idir0 , texelPos, 0 ) ;
    uvec4 dir1  = texelFetch(idir1 , texelPos, 0 ) ;

    float dx = lx/float(mx*my) ;  
    l = (   texelFetch( icolor , unpack( NORTH ), 0 )
        +   texelFetch( icolor , unpack( SOUTH ), 0 )
        +   texelFetch( icolor , unpack( EAST  ), 0 )
        +   texelFetch( icolor , unpack( WEST  ), 0 )
        +   texelFetch( icolor , unpack( UP    ), 0 )
        +   texelFetch( icolor , unpack( DOWN  ), 0 )
        -6.*texelFetch( icolor , texelPos, 0 )      )/(dx*dx) ;
    return ;
}
/*========================================================================
 * main body of the shader
 *========================================================================
 */
void main(){
    vec4 lap ;
    ivec2 texelPos ;

    laplacian( icolor4, texelPos, lap ) ;

    // localizing color values ...........................................
    vec4 color0  = texelFetch(icolor0 , texelPos, 0) ;
    vec4 color1  = texelFetch(icolor1 , texelPos, 0) ;
    vec4 color2  = texelFetch(icolor2 , texelPos, 0) ;
    vec4 color3  = texelFetch(icolor3 , texelPos, 0) ;
    vec4 color4  = texelFetch(icolor4 , texelPos, 0) ;
    vec4 color5  = texelFetch(icolor5 , texelPos, 0) ;
    vec4 color6  = texelFetch(icolor6 , texelPos, 0) ;
    vec4 color7  = texelFetch(icolor7 , texelPos, 0) ;
    vec4 color8  = texelFetch(icolor8 , texelPos, 0) ;
    vec4 color9  = texelFetch(icolor9 , texelPos, 0) ;
    vec4 color10 = texelFetch(icolor10, texelPos, 0) ;

    // m .................................................................
    float minf  = 1.0/(1.0+exp((-(V+39.57))/9.871)) ;
    float tm    = 1.0/(6.765*exp((V+11.64)/34.77)
           +8.552*exp(-(V+77.42)/5.955)) ;

    m = RL1( m , minf , tm, dt ) ;

    // hfast, hslow ......................................................
    float hinf  = 1.0/(1.+exp((V+82.90)/6.086)) ;
    float thf   = 1.0/(1.432e-5*exp(-(V+1.196)/6.285)
            +6.149*exp((V+0.5096)/20.27)) ;
    float ths   = 1.0/(0.009794*exp(-(V+17.95)/28.05)
            +0.3343*exp((V+5.730)/56.66)) ;
    
    hfast = RL1( hfast, hinf, thf, dt ) ;
    hslow = RL1( hslow, hinf, ths, dt ) ;

    float Ahf   = 0.99 ; float Ahs = 0.01 ;
    float h     = Ahf*hfast + Ahs*hslow ;

    // j .................................................................
    float jinf  = hinf ;
    float tj    = 2.038+1.0/(0.02136*exp(-(V+100.6)/8.281)
            +0.3052*exp((V+0.9941)/38.45)) ;

    j = RL1( j, jinf, tj, dt ) ;

    // hCaMKslow .........................................................
    float hCaMKinf  = 1.0/(1.0+exp((V+89.1)/6.086)) ;
    float thCaMKs   = 3.0*ths ;
    float hCaMKfast = hfast ;

    hCaMKslow = RL1( hCaMKslow, hCaMKinf, thCaMKs, dt ) ;

    float hCaMK = Ahf*hCaMKfast + Ahs*hCaMKslow ;

    // jCaMK .............................................................
    float   jCaMKinf = jinf ;
    float   tjCaMK  =1.46*tj ;

    jCaMK = RL1( jCaMK, jCaMKinf, tjCaMK, dt ) ;

    // mL ................................................................
    float   mLinf = 1.0/(1.0+exp((-(V+42.85))/5.264)) ;
    float   tLm   = tm ;
    
    mL = RL1( mL, mLinf, tLm, dt ) ;

    // hL ................................................................
    float hLinf     = 1.0/(1.0+exp((V+87.61)/7.488)) ;
    float thL = 200.0 ;

    hL = RL1( hL, hLinf, thL, dt ) ;

    // hLCaMK ............................................................
    float hLCaMKinf = 1./(1.+exp((V+93.81)/7.488)) ;
    float tLCaMK = 3.*thL ;

    hLCaMK = RL1( hLCaMK, hLCaMKinf, tLCaMK, dt ) ;

    // xK1 ...............................................................
    float   xK1inf  = 1./
            (   1.  +   exp(   -(V+2.5538*Ko + 144.59  )/
                                     (1.5692*Ko + 3.8115 )  )   ) ;


    float   txK1    = (
            122.2/
            (   exp(   -( V+127.2   )/20.36 ) +
                exp(    ( V+236.8   )/69.33 )              ) 
        ) * Ct_xk1 ;

    xK1 = RL1(xK1 , xK1inf, txK1, dt ) ;

    // a (sa) ............................................................
    float   ainf    = 1./
            (   1. +    exp(  -(V-14.34)/14.82     )       )  ;
    
    float   ta      = (
            1.0515/
            (   1./ (   1.2089*(1.+exp(-(V-18.41)/29.38))  ) +
                3.5/(   1. + exp(  (V+100.)/29.38  )   )   ) 
        )*Ct_a ;
    
    sa = RL1 ( sa, ainf, ta , dt ) ;

    // ifast, islow ......................................................
    float   delta_epi   = ( cellType == EPI ) ?  1.0 - 
                    0.95/(1.0 + exp((V+70.0)/5.0)) : 1.0 ;

    float   iinf        = 1./
            (   1. + exp(   (V+43.94)/5.711    )           )  ;
    
    float   tifast      = (4.562 + 1./
            (   0.3933*exp(-(V+100.)/100.  ) +
                0.08004*exp((V+50.0)/16.59 )               ) 
        )*delta_epi*Ct_ifast ;

    float   tislow      = (23.62 +
            1./( 0.001416*exp(-(V+96.52)/59.05 )
                +1.7808e-8*exp((V+114.1)/8.079 )           ) 
        )*delta_epi*Ct_islow ;

    ifast = RL1( ifast, iinf, tifast, dt ) ;
    islow = RL1( islow, iinf, tislow, dt ) ;

    // kiii ..............................................................
    float vfort   = V*fort ;
    float vffort  = vfort*F ;

    float   alphaCass ;
    float   betaCao ;
    float   alphaNass ; 
    float   betaNao ;
    float   alphaKss ;
    float   betaKo ;

    if ( abs(vfort)>0.01){
        alphaCass = (zCa*zCa*vffort*gCai*exp(zCa*vfort))/
                            (   exp(zCa*vfort) - 1.0        ) ; 
        betaCao     = zCa*zCa*vffort*gCao*Cao/
                        (   exp(zCa*vfort) - 1.0            )  ;
        alphaNass = zNa*zNa*vffort*gNai*exp(zNa*vfort)/
                            (   exp(zNa*vfort) - 1.0       ) ;

        betaNao =  zNa*zNa*vffort*gNao*Nao/
                            (   exp(zNa*vfort) - 1.0       ) ;
        alphaKss = zK*zK*vffort*gKi*exp(zK*vfort)/
                            (   exp(zK*vfort) - 1.0        ) ;
        betaKo = zK*zK*vffort*gKo*Ko/(exp(zK*vfort)-1.) ;

    }else{
        alphaCass = (zCa*F*gCai + zCa*V*F*gCai ) ;
        betaCao = zCa*F*gCao*Cao/exp(zCa*vfort) ;
        alphaNass = zNa*gNai*(F+ vffort*zNa)  ;
        betaNao = zNa*F*gNao*Nao/
                            (   exp(zNa*vfort)        ) ;
        alphaKss = zK*gKi*(F + vffort*zK) ;
        betaKo = zK*F*gKo*Ko/exp(zK*vfort) ;

    }

    float   PsiCa       = alphaCass*Cass - betaCao ;
    float   PCa         = 0.0001*SPCa ;
    float   IbarCaL     = PCa*PsiCa ;

    float   PsiCaNa     = alphaNass*Nass - betaNao ;
    float   PCaNa       = 0.00125*PCa ;
    float   IbarCaNa    = PCaNa*PsiCaNa ;

    float   PCaK        = 3.574e-4*PCa ;
    float   PsiCaK      = alphaKss*Kss - betaKo ;
    float   IbarCaK     = PCaK*PsiCaK ;

    float   PCaCaMK     = 1.1*PCa ;
    float   IbarCaLCaMK = PCaCaMK*PsiCa ;

    float   PCaNaCaMK   = 0.00125*PCaCaMK ;
    float   IbarCaNaCaMK= PCaNaCaMK*PsiCaNa ;

    float   PCaKCaMK    = 3.574e-4*PCaCaMK ;
    float   IbarCaKCaMK = PCaKCaMK*PsiCaK ;

    float   Affast      = 0.6 ;
    float   Afslow      = 1.-Affast ;
    float   f           = Affast*ffast + Afslow*fslow ;

    float   AfCafast    =  0.3 +
               0.6/(    1. + exp((V-10.)/10.)              ) ;
    float   AfCaslow    = 1. - AfCafast ;
    float   fCa         = AfCafast*fCafast + AfCaslow*fCaslow ;

    float   fCaMKslow   = fslow ;
    float   AfCaMKfast  = Affast ;
    float   AfCaMKslow  = Afslow ;
    float   fCaMK       = AfCaMKfast*fCaMKfast + AfCaMKslow*fCaMKslow ;

    float   fCaCaMKslow = fCaslow ;
    float   AfCaCaCMfast= Affast ;
    float   AfCaCaCMslow= Afslow ;
    float   fCaCaMK     = 
        fCaCaMKfast*AfCaCaCMfast + fCaCaMKslow*AfCaCaCMslow ;


    float   CaMKb       = CaMKo*(1.0-CaMKt)/(1.0+KmCaM/Cass) ;
    float   CaMKa       = CaMKb + CaMKt ;

    float   fICaLCaMK   = 1./(1.+KmCaMK/CaMKa) ;

    float   alpha_I = d*(1.0 - fICaLCaMK )*( f*(1.-n) + fCa*n*jCa) ;
    float   beta_I  = d*fICaLCaMK*( fCaMK*(1.-n) + fCaCaMK*n*jCa ) ;

    // CaMKtrap ..........................................................
    float   dCaMKt2dt = ACaMK*CaMKb*(CaMKb + CaMKt) - bCaMK*CaMKt ;

    CaMKt += dCaMKt2dt*dt ;

    // ICaL ..............................................................
    float   ICaL    = C_CaL*(alpha_I*IbarCaL    + beta_I*IbarCaLCaMK    ) ;

    // ICaNa .............................................................
    float   ICaNa   = C_CaNa*(alpha_I*IbarCaNa  + beta_I*IbarCaNaCaMK   ) ;

    // ICaK ..............................................................
    float   ICaK    = C_CaK*(alpha_I*IbarCaK    + beta_I*IbarCaKCaMK    ) ;

    // Kss, JdiffK .......................................................
    float   tdiffK  = 2.0 * Ct_diffK ;
    float   JdiffK  = C_diffK*(Kss -Ki)/tdiffK ;

    float   dKss2dt = -ICaK*Acap/(F*vss) - JdiffK ;
    Kss += dKss2dt*dt ;

    // JrelNP ............................................................
    float   bjsr        = -ICaL/(1.0+pow8(1.5/Cajsr)) ;
    float   ajsr        = 1.0/(1.0+(0.0123/Cajsr) ) ;

    float   JrelNPinf   = arel*bjsr*SJrel ;
    float   trelNP      = max(bt*ajsr ,0.001) * Ct_relNP ;

    JrelNP = RL1( JrelNP, JrelNPinf , trelNP, dt  ) ;

    // JrelCaMK ..........................................................
    float   JrelCaMKinf = arelCaMK*bjsr*SJrel ;
    float   trelCaMK    = max( btCaMK * ajsr , 0.001 ) * Ct_relCaMK ;
    
    JrelCaMK = RL1( JrelCaMK, JrelCaMKinf, trelCaMK, dt ) ;

    // Jrel ..............................................................
    CaMKb       = CaMK0*(1.0-CaMKt)/(1.0 + KmCaM/Cass) ;
    CaMKa       = CaMKb + CaMKt ;

    float   frelCaMK    = 1.0/(1.0 + KmCaMK/CaMKa ) ;
    float   Jrel        = (1.0 - frelCaMK)*JrelNP +  frelCaMK*JrelCaMK ;
    Jrel               *= C_rel ;

    // Jup ...............................................................
     float   JupNP       = 0.004375*Cai/(0.00092 + Cai) ;
            JupNP       *= SJup ;
            JupNP       *= C_upNP ;

    float   dKmPLB      = 0.00017 ;
    float   dJupCAMK    = 1.75 ;

    float   JupCaMK     = ( 1.0 + dJupCAMK )*0.004375*Cai/
                (   0.00092 - dKmPLB + Cai                  ) ;
            JupCaMK    *= SJup ;
            JupCaMK    *= C_upCaMK ;

    float   fupCaMK = frelCaMK ;
    float   Jleak   = 0.0039375*Cansr/15.0 ;
            Jleak  *= C_leak ;

    float   Jup  = ( 1.0 - fupCaMK )*JupNP + fupCaMK*JupCaMK - Jleak ;
            Jup *= C_up ;

    // Cansr .............................................................
    float   ttr         = 100.0 * Ct_tr ;
    float   Jtr         = ( Cansr - Cajsr )/ttr ;
            Jtr        *= C_tr ;


    float   dCansr2dt = Jup - Jtr*vjsr/vnsr ;

    Cansr += dCansr2dt*dt ;

    // Cajsr .............................................................
    float   aCajsrs= KmCSQN + Cajsr ;
    aCajsrs *= aCajsrs ;
    float   bCajsr = 1.0/(1.0 + CSQN*KmCSQN/aCajsrs ) ;

    float   dCajsr2dt = bCajsr*(Jtr - Jrel) ;
    Cajsr += dCajsr2dt*dt ;

    // INaCai , INaCass ..................................................
        float   hCa = exp(qCa*vfort) ;
    float   hNa = exp(qNa*vfort) ;

    float   Ca[2] ;
    float   Na[2] ;
    float   INaCaArray[2] ;
    float   aGNaCa[2] ;
    float   C_NaCaArray[2] ;

    aGNaCa[ i ] = 0.8*SGNaCa ;
    aGNaCa[ ss] = 0.2*SGNaCa ;

    C_NaCaArray[ i ] = C_NaCai ;
    C_NaCaArray[ ss] = C_NaCass ;

    Ca[ss]  = Cass ;
    Ca[i ]  = Cai ;
    Na[ss]  = Nass ;
    Na[i ]  = Nai ;

    float   h1 , h2 , h3 , h4 ,
            h5 , h6 , h7 , h8 ,
            h9 , h10, h11, h12;

    float   k1 , k2 , k3 , k4 ,
            k5 , k6 , k7 , k8 ;
    float   k3p, k3pp, k4p, k4pp ;

    float   x1 , x2 , x3 , x4 ;
    float   E1 , E2 , E3 , E4 ;
    float   xs ;

    float   KmCaAct2CaS ;
    float   allo ;
    float   JNaCaNa ;
    float   JNaCaCa ;

    /* Coefficients independent of i, ss values     */
    h7   = 1.0 + Nao*(1.0 + 1.0/hNa)/kNa3 ;
    h8   = Nao/(kNa3*hNa*h7) ;
    h9   = 1.0/h7 ;
    h10  = kasymm + 1.0 + Nao*(1.0+Nao/kNa2)/kNa1 ;
    h11  = Nao*Nao/(h10*kNa1*kNa2) ;
    h12  = 1.0/h10 ;

    k1   = h12*Cao*kCaon ;
    k2   = kCaoff ;
    k3p  = h9*omegaCa ;
    k3pp = h8*omegaNaCa ;
    k3   = k3p + k3pp ;

    /* Coefficients depending on i, and ss values   */
    for(int Y=0 ; Y<2 ; Y++){
        h1      = 1.0 + Na[Y]*(1.+hNa)/kNa3 ;
        h2      = Na[Y]*hNa/( kNa3*h1  ) ;
        h3      = 1.0/h1 ;
        h4      = 1.0+ Na[Y]*(1.0 + Na[Y]/kNa2)/kNa1 ;
        h5      = Na[Y]*Na[Y]/( h4*kNa1*kNa2   ) ;
        h6      = 1.0/h4 ;

        k4p     = h3*omegaCa/hCa ;
        k4pp    = h2*omegaNaCa ;
        k4      = k4p + k4pp ;
        k5      = kCaoff ;
        k6      = h6*Ca[Y]*kCaon ;
        k7      = h5*h2*omegaNa ;
        k8      = h8*h11*omegaNa ;
        x1      = k2*k4*(k7+k6) + k5*k7*(k2+k3) ;
        x2      = k1*k7*(k4+k5) + k4*k6*(k1+k8) ;
        x3      = k1*k3*(k7+k6) + k8*k6*(k2+k3) ;
        x4      = k2*k8*(k4+k5) + k3*k5*(k1+k8) ;
        xs      = x1 + x2 + x3 + x4 ;

        E1      = x1/xs ;
        E2      = x2/xs ;
        E3      = x3/xs ;
        E4      = x4/xs ;

        KmCaAct2CaS = KmCaAct/Ca[Y] ;
        KmCaAct2CaS *= KmCaAct2CaS ;

        allo    = 1./(1. + KmCaAct2CaS ) ;
        JNaCaNa = 3.0*(E4*k7 - E1*k8) + E3*k4pp - E2*k3pp ;
        JNaCaCa = E2*k2 - E1*k1 ;

        INaCaArray[Y]= C_NaCaArray[Y]*GNaCa*aGNaCa[Y]*allo*
                        (zNa*JNaCaNa + zCa*JNaCaCa) ;
    }

    float INaCai    = INaCaArray[ i  ] ;
    float INaCass   = INaCaArray[ ss ] ;

    // ICab, IpCa ........................................................
    float ICab  = C_Cab*PCab*(alphaCass*Cai - betaCao ) ;
    float IpCa  = C_pCa*GpCa*Cai/(0.0005+Cai) ;

    // Cai ...............................................................
    float   tdiffCa = tdiffCaCnst * Ct_diffCa ;
    float   JdiffCa = (Cass - Cai)/tdiffCa ;
            JdiffCa*= C_diffCa ;

    float CMDN = CMDNI*SCMDN ;

    float b1    = KmCMDN + Cai ;
    b1 *= b1 ;

    float b2    = KmTRPN + Cai ;
    b2 *= b2 ;

    float betaCai = 1.0/(   1.0 +
                            CMDN*KmCMDN/b1 +
                            TRPN*KmTRPN/b2      ) ;

    float   dCai2dt = betaCai*
                (   -( IpCa + ICab - 2.0*INaCai )*Acap/(2.0*F*vmyo)
                    - Jup*vnsr/vmyo
                    + JdiffCa*vss/vmyo                              ) ;
    Cai += dCai2dt*dt ;

    // ENa, EK, EKs ......................................................
    float   ENa         = rtof*log( Nao/Nai ) ;
    float   EK          = rtof*log( Ko/Ki   ) ;
    float   EKs         = rtof*log((Ko+PRNaK*Nao)/(Ki + PRNaK*Ki)) ;

    // INafast ...........................................................
    float   fINaCaMK    = 1.0/(1.0 + (KmCaMK/CaMKa) ) ;
    
    float INafast = GNafast*(V-ENa)*m*m*m*((1.-fINaCaMK)*h*j
            + fINaCaMK*hCaMK*jCaMK) ;

    // INalate ...........................................................
    float fINaLp = (1.0/(1.0+KmCaMK/CaMKa)) ;
    float INalate = GNalate*(V-ENa)*mL*((1.-fINaLp)*hL+fINaLp*hLCaMK) ;

    // INa ...............................................................
    float INa = C_Na*(C_Nafast*INafast + C_Nalate*INalate)*1.5 ;
    
    // INaCa .............................................................
    float   INaCa       = C_NaCa*(INaCai + INaCass) ;

    // Ito ...............................................................
    float   Aifast      = 1./
            (    1. +   exp(   (V-213.6)/151.2 )           )  ;
    float   Aislow      = 1.0 - Aifast ;
    float   iavg        = Aifast*ifast + Aislow*islow ;


    float   AiCaMKfast  = Aifast ;
    float   AiCaMKslow  = Aislow ;
    float   iCaMK       = AiCaMKfast*iCaMKfast + AiCaMKslow*iCaMKslow;

    float   fItoCaMK    = fINaCaMK ;

    float   Ito         = C_to*SGto*Gto*( V - EK  )*
        ( ( 1.0 - fItoCaMK )*sa*iavg    +   fItoCaMK*aCaMK*iCaMK    ) ;

    // IKr ...............................................................
    float   Axrfast     = 1./
            (   1.  +   exp(    (V+54.81)/38.21    )       )  ;
    
    float   Axrslow     = 1.0 - Axrfast ;
    float   xr          = Axrfast*xrfast    +   Axrslow*xrslow ;

    float   RKr         = 1./( ( 1.+exp((V+55.)/75.) )*
                             ( 1.+exp((V-10.)/30.) )       ) ;

    float   GKr         = 0.046*SGKr ;

    float   IKr         = C_Kr*GKr*sqrt(Ko/5.4)*xr*RKr*(V-EK) ;

    // IKs ...............................................................
    float   GKs         = 0.0034*SGKs ;

    float   IKs         = C_Ks*GKs*(1.0 + 0.6/(1.0 + pow(3.8e-5/Cai, 1.4)))*
                            xs1*xs2*( V - EKs   ) ;

    // IK1 ...............................................................
    float   RK1         = 1./
            (   1. + exp((  V + 105.8 - 2.6*Ko  )/9.493 )   )  ;
    float   GK1         = 0.1908*sqrt(Ko)*SGK1 ;
    float   IK1         = C_K1*GK1*xK1*RK1*( V - EK ) ;

    // INaK ..............................................................
    float   KNai        = K0Nai*exp( Delta*vfort/3.0       )  ;   
    float   KNao        = K0Nao*exp( (1.0-Delta)*vfort/3.0 ) ;

    float   P           = SP/(  1.0 + H/KHP + Nai/KNaP + Ki/KKP     ) ;

    float   Nao2KNao    = Nao/KNao ;
    float   Nai2KNai    = Nai/KNai ;
    float   Ko2KKo      = Ko/KKo ;
    float   Ki2KKi      = Ki/KKi ;

    float   OPNao2KNao  = 1. + Nao2KNao ;
    float   OPNai2KNai  = 1. + Nai2KNai ;
    float   OPKo2KKo    = 1. + Ko2KKo ;
    float   OPKi2KKi    = 1. + Ki2KKi ;

    float   alpha1      = kp1*Nai2KNai*Nai2KNai*Nai2KNai/
        (   OPNai2KNai*OPNai2KNai*OPNai2KNai + OPKi2KKi*OPKi2KKi - 1.0  ) ;

    float   beta1       = km1*MgADP ;

    float   alpha2      = kp2 ;

    float   beta2       = km2*Nao2KNao*Nao2KNao*Nao2KNao/
        (   OPNao2KNao*OPNao2KNao*OPNao2KNao + OPKo2KKo*OPKo2KKo - 1.0  ) ;

    float   alpha3      = kp3*Ko2KKo*Ko2KKo/
        (   OPNao2KNao*OPNao2KNao*OPNao2KNao + OPKo2KKo*OPKo2KKo - 1.0  ) ;

    float   beta3       = km3*P*H/(   1.0 + MgATP/KMgATP                ) ;

    float   alpha4      = kp4*(MgATP/KMgATP)/( 1. + MgATP/KMgATP        ) ;

    float   beta4       = km4*Ki2KKi*Ki2KKi/
        (   OPNai2KNai*OPNai2KNai*OPNai2KNai + OPKi2KKi*OPKi2KKi - 1.0  ) ;

    float x11          =   alpha4*alpha1*alpha2 +  beta2*beta4*beta3
                +   alpha2*beta4*beta3   +  beta3*alpha1*alpha2   ;

    float x22          =   beta2*beta1*beta4    +  alpha1*alpha2*alpha3
                +   alpha3*beta1*beta4   +  alpha2*alpha3*beta4   ;

    float x33          =   alpha2*alpha3*alpha4 +  beta3*beta2*beta1
                +   beta2*beta1*alpha4   +  alpha3*alpha4*beta1   ;

    float x44          =   beta4*beta3*beta2    +  alpha3*alpha4*alpha1
                        +   beta2*alpha4*alpha1  +  beta3*beta2*alpha1    ;

    float   xsum    = x11 + x22 + x33 + x44 ;
    float   E11     = x11/xsum ;
    float   E22     = x22/xsum ;
    float   E33     = x33/xsum ;
    float   E44     = x44/xsum ;

    float   JNaKNa  = C_NaKNa   * 3.0 *( E11*alpha3   -   E22*beta3    ) ;
    float   JNaKK   = C_NaKK    * 2.0 *( E44*beta1    -   E33*alpha1   ) ;
    float   INaK    = C_NaK     * SGNaK * 30. *( JNaKNa+   JNaKK       ) ;

    // INab ..............................................................
    float   aNai        = alphaNass/gNai ;
    float   bNao        = betaNao/gNao ;

    float   INab        = C_Nab*PNab*(aNai*Nai - bNao) ;

    // IKb ...............................................................
    float   xKb         = 1.0/
            (   1.0 + exp( ( 14.48 - V )/18.34 )           )  ;
    float   GKb         = 0.003*SGKb ;

    float   IKb         = C_Kb*GKb*xKb*(V-EK) ;

    // JdiffNa, JdiffK ...................................................
    float   tauDiffNa   = 2.0 * Ct_diffNa ;
    float   tauDiffK    = 2.0 * Ct_diffK ;

    float   JdiffNa     = C_diffNa * ( Nass    - Nai   )/tauDiffNa ;
    JdiffK      = C_diffK  * ( Kss     - Ki    )/tauDiffK ;

    // Ki ................................................................
    float   dKi2dt      =
        -( Ito + IKr + IKs + IK1 +IKb - 2.0*INaK )*Acap/(F*vmyo) +
        JdiffK*vss/vmyo ;
    Ki +=  dKi2dt*dt ;

    // Nai ...............................................................
    float   dNai2dt     =
        -( INa + 3.0*INaCai + 3.0*INaK + INab)*Acap/(F*vmyo) +
        JdiffNa*vss/vmyo ;
    Nai += dNai2dt*dt ;

    // Nass ..............................................................
    float   dNass2dt    =
        -( ICaNa + 3.0*INaCass  )*Acap/(F*vss)  - JdiffNa ;
    Nass += dNass2dt*dt ;

    // Cass ..............................................................
    tdiffCa = 0.2 ;
    JdiffCa = (Cass - Cai)/tdiffCa ;
    JdiffCa*= C_diffCa ;

    b1 = KmBSR + Cass ;
    b1 *= b1 ;

    b2 = KmBSL + Cass ;
    b2 *= b2 ;

    float betaCass = 1.0/(  1.0 + BSR*KmBSR/b1 + BSL*KmBSL*b2   ) ;

    float dCass2dt = betaCass*
                (   -( ICaL - 2.0*INaCass )*Acap/(2.0*F*vss)
                    + Jrel*vjsr/vss
                    - JdiffCa                                   ) ;

    Cass += dCass2dt*dt ;

    // Isum ..............................................................
    float Isum =   INa
                +   Ito
                +   ICaL
                +   ICaNa
                +   ICaK
                +   IKr
                +   IKs
                +   IK1
                +   INaCa
                +   INaK
                +   INab
                +   ICab
                +   IKb
                +   IpCa 
                ;
    // V .................................................................
    float dv2dt = lap.r*diffCoef - Isum/C_m ;
    
    V += dv2dt*dt ;

    // v: used for tracking wave back ....................................
    v = hslow ;

    // output color values ...............................................
    ocolor4   = vec4( color4  ) ;
    ocolor5   = vec4( color5  ) ;
    ocolor6   = vec4( color6  ) ;
    ocolor7   = vec4( color7  ) ;
    ocolor8   = vec4( color8  ) ;
    ocolor9   = vec4( color9  ) ;
    ocolor10  = vec4( color10 ) ;

    return ;
}
</script><!-- end of comp2 shader's source code -->

<!-- ***************************************************************** -->
<script id='click' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * click.frag   : Create activations on the tissue
 * 
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Thu 04 May 2023 17:10:13 (EDT)
 * PLACE        : Maryland, USA.
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */

precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


// interfacial variables .................................................
in vec2 cc ;

uniform sampler2D   icolor4 ;
uniform sampler2D   compressed3dCrdt ;

uniform sampler2D   projectedCoordinates ;
uniform vec2        clickPosition ;

uniform float       clickRadius ;

// output color ..........................................................
layout (location = 0) out vec4 ocolor4 ;

#define aCaMK       color0.r
#define iCaMKfast   color0.g
#define iCaMKslow   color0.b
#define d           color0.a

#define ffast       color1.r
#define fslow       color1.g
#define fCafast     color1.b 
#define fCaslow     color1.a

#define jCa         color2.r
#define fCaMKfast   color2.g
#define fCaCaMKfast color2.b
#define n           color2.a

#define xrfast      color3.r
#define xrslow      color3.g
#define xs1         color3.b
#define xs2         color3.b

#define vlt         color4.r
#define V           color4.r
#define v           color4.g
#define xK1         color4.b
#define CaMKtrap    color4.a
#define CaMKt       CaMKtrap

#define Cansr       color5.r
#define Cajsr       color5.g
#define Cass        color5.b
#define Cai         color5.a 

#define Kss         color6.r
#define Ki          color6.g
#define Nass        color6.b
#define Nai         color6.a

#define m           color7.r
#define hfast       color7.g
#define hslow       color7.b
#define j           color7.a

#define hCaMKslow   color8.r
#define jCaMK       color8.g
#define mL          color8.b
#define hL          color8.a

#define JrelNP      color9.r
#define hLCaMK      color9.g


#define JrelCaMK    color10.r
#define sa          color10.g
#define ifast       color10.b
#define islow       color10.a

#define tvlt        color11.r
#define time        color11.g

#define vlt_txtr    icolor4
#define vchannel r


/*========================================================================
 * main
 *========================================================================
 */
void main(){
    vec4 color4 = texture( icolor4 , cc ) ;
    vec3 texelCrdt = texture(compressed3dCrdt, cc ).xyz ;
    vec3 clickCrdt = texture(projectedCoordinates, clickPosition ).xyz ; 

    if (length(texelCrdt - clickCrdt )<clickRadius ){
        vlt = 1. ;
    }

    ocolor4 = vec4(color4) ;
    return ;
}
</script><!-- end of click shader's source code -->


<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- main script - JavaScript code                                     -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<script>
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * app.js       : OVV Minimal Model  
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * PLACE        : Maryland, USA.
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */

"use strict" ;

/*========================================================================
 * get the source code for fragment shaders
 *========================================================================
 */
function source( id ){
    return document.getElementById( id ).innerHTML ;
}
/*========================================================================
 * Global Parameters
 *========================================================================
 */
let env = {} ;

/*========================================================================
 * import surface data
 *========================================================================
 */
let loadedJSON ;

/*========================================================================
 * let the user select the file
 *========================================================================
 */
var fileInput = document.getElementById('json_structure') ;

fileInput.onchange = function(){
  let file = fileInput.files[0] ;
  if ( !file ){
      return ;
  }
  let reader = new FileReader() ;
  reader.readAsText(file) ;

  reader.onload = function(e){
      let result = e.target.result ;
      loadedJSON = JSON.parse(result) ;
      $('#chooser').hide() ;
      $('.loaded').show() ;
      loadWebGL() ;
  } ;
}

var gl = Abubu.gl ;

/*========================================================================
 * Read structure from file on the server for debugging purposes
 * NOTE: if not debugging comment out this section
 *========================================================================
 */
//let structureFile = new XMLHttpRequest();
//
//structureFile.onreadystatechange = () => {
//    if (structureFile.readyState == 4 && structureFile.status == 200) {
//        loadedJSON = JSON.parse(structureFile.responseText);
//        console.log(loadedJSON) ;
//        $('#chooser').hide() ;
//        $('.loaded').show() ;
//
//        loadWebGL() ;
//    }
//};
//console.log("324") ;
//structureFile.open("GET", 
//        "/jsons/AtrialExamples/02-350um-192x192x192_lra_grid.json", true);
//structureFile.send();
//

/*========================================================================
 * WallTime
 *========================================================================
 */
class WallTimer{
    constructor(opts={}){
        this._duration  = opts?.duration ?? 100 ; /* duration of the
                                        measurements in miliseconds of
                                        simulated electrical activity   */
        this._start     = opts?.start ?? 0 ; /* physical time of the
                                                measurements            */
                                             
        this._startTime = new Date().getTime() ;    /* start wall-time of
                                                       the measurements */
        this._endTime   = NaN ;
        this._started   = false;    /* flag that wall-time 
                                       measurements have started        */
        this._finished  = false ;   /* flag indicating if wall-time
                                       measurements have ended          */
        this._paused    = false ;    /* flag indicating if measurements 
                                       are paused                       */
        this._lapsedTime= 0 ;       /* lapsed time of the wall-time
                                       measurements                     */
    }// end of constructor ...............................................

/*------------------------------------------------------------------------
 * getters and setters of the class
 *------------------------------------------------------------------------
 */
    get duration(){
        return this._duration ; 
    }

    set duration(v){
        this._duration = v ;
        this.reset() ;
    }

    get paused(){
        return this._paused ;
    }

    set paused(v){
        if (v & !this.paused & !this.finished){
            this.endTime = new Date().getTime() ;
            this._started = false ;
            this._lapsedTime += (this.endTime - this.startTime) ;
            this._paused = v ;
        }else if ( !v ){
            this._paused = v ;
        }
        return ;
    }
    
    get start(){
        return this._start ;
    }

    set start(v){
        this._start = v ;
    }

    get startTime(){
        return this._startTime ;
    }

    set startTime(v){
        this._startTime = v ;
    }

    get endTime(){
        return this._endTime ;
    }

    set endTime(v){
        this._endTime =v  ;
    }

    get lapsedTime(){
        return this._lapsedTime ;
    }

    get finished(){
        return this._finished ;
    }
    set finished(v){
        this._finished = v ;
    }

    get started(){
        return this._started ;
    }

    set started(v){
        this._started = v ;
    }

    get end(){
        return this.start + this.duration ;
    }

    get progress(){
        if (this.finished) return 100 ;
        return Math.round(100*( env.time - this.start)/this.duration) ;
    }

/*------------------------------------------------------------------------
 * Methods
 *------------------------------------------------------------------------
 */
    // Measure wall-time .................................................
    measure(){
        if ( !env.running & !this.paused ){
            this.paused  = true ;
            return ;
        }
        if ( !env.running ) return ;

        if ( !this.started & !this.paused & env.time >= this.start ){
            this.started = true ;
            this.startTime = new Date().getTime() ; 
            return ;
        }
        
        if ( !this.finished & !this.paused & env.time >= this.end ){
            this.finished = true ;
            this._endTime = new Date().getTime() ;
            this._lapsedTime += (this.endTime - this.startTime) ;
        }
    }

    // Reset measurements ................................................
    reset(){
        this._started       = false ;
        this.start          = env.time ;
        this._finished      = false ;
        this._lapsedTime   = 0 ;
    }
}

/*========================================================================
 * Initialization of the GPU and Container
 *========================================================================
 */
function loadWebGL()
{
    env.allFloats   = [] ; // uniform shared floats
    env.allInts     = [] ; // uniform shared integers
    env.allTxtrs    = [] ; // uniform shared textures

/*------------------------------------------------------------------------
 * display parameters
 *------------------------------------------------------------------------
 */
    env.colormap    = 'rainbowHotSpring' ;
    env.dispWidth   = 512 ;
    env.dispHeight  = 512 ;

    env.canvas_1 = document.getElementById("canvas_1") ;
    env.canvas_2 = document.getElementById("canvas_2") ;
    env.canvas_1.width  = env.dispWidth ;
    env.canvas_1.height = env.dispHeight ;

/*------------------------------------------------------------------------
 * load the structure and process it
 *------------------------------------------------------------------------
 */
    env.mx = loadedJSON.mx ; env.my = loadedJSON.my ;
    env.allInts = [...env.allInts, 'mx','my' ] ;

    env.structure = new Abubu.StructureFromJSON( loadedJSON ) ;

    env.width                   = env.structure.width ;
    env.height                  = env.structure.height ;
    env.fwidth                  = env.structure.fwidth ; 
    env.fheight                 = env.structure.fheight ;

    env.fullTexelIndex          = env.structure.fullTexelIndex ;
    env.compressedTexelIndex    = env.structure.compressedTexelIndex ;
    env.full3dCrdt              = env.structure.full3dCrdt ;
    env.compressed3dCrdt        = env.structure.compressed3dCrdt ;
    env.normals                 = env.structure.normals ;

    env.loaded = true ;

    env.allTxtrs = [...env.allTxtrs, 'compressed3dCrdt' ] ;  
    

/*------------------------------------------------------------------------
 * zero-flux directionator 
 *------------------------------------------------------------------------
 */
    env.dir0 = new Abubu.Uint32Texture( env.width, env.height ) ;
    env.dir1 = new Abubu.Uint32Texture( env.width, env.height ) ;

    env.idir0 = env.dir0 ;
    env.idir1 = env.dir1 ;

    env.directionator = new Abubu.Solver({
        fragmentShader : source('directionator') ,
        uniforms : {
            mx : { type : 'i' , value : env.mx } ,
            my : { type : 'i' , value : env.my } ,
            fullTexelIndex : { 
                type : 't', value : env.fullTexelIndex 
            } ,
            compressedTexelIndex : { 
                type : 't', value : env.compressedTexelIndex
            } ,
        },
        targets: {
            odir0 : { location : 0, target : env.dir0 } ,
            odir1 : { location : 1, target : env.dir1 } ,
        }
    } ) ;
    env.directionator.render() ; 

    env.allTxtrs = [...env.allTxtrs, 'idir0', 'idir1' ] ;


/*------------------------------------------------------------------------
 * textures for time-stepping
 *------------------------------------------------------------------------
 */
    env.fcolors = [] ;
    env.scolors = [] ;

    for(let i=0; i<11; i++){
        env['fcolor'+i] = new Abubu.Float32Texture( 
                env.width, env.height, { pairable : true } ) ;
        env['scolor'+i] = new Abubu.Float32Texture( 
                env.width, env.height, { pairable : true } ) ;
        env.fcolors.push(env['fcolor'+i]) ;
        env.scolors.push(env['scolor'+i]) ;
    }
    env.colors = [ ...env.fcolors, ...env.scolors ] ;

/*------------------------------------------------------------------------
 * OVVR Targets
 *------------------------------------------------------------------------
 */
    class OvvrTargets1{
        constructor( colors ){
            for(let i=0; i<4 ; i++){
                this["ocolor"+i] = {location : i, target: colors[i]} ;
            }
        }
    }
    class OvvrTargets2{
        constructor( colors ){
            for ( let i =0 ; i< 7 ; i++){
                let j=4+i ;
                this["ocolor"+j] = { location : i, target : colors[j] } ;
            }
        }
    }

/*------------------------------------------------------------------------
 * init solvers
 *------------------------------------------------------------------------
 */
    // init sets 0 to 3 ..................................................
    env.finit1 = new Abubu.Solver({
        fragmentShader : source( 'init1' ) ,
        targets : new OvvrTargets1( env.fcolors ) ,
    } ) ;
    env.sinit1 = new Abubu.Solver({
        fragmentShader : source( 'init1' ) ,
        targets : new OvvrTargets1( env.scolors ) ,
    } ) ;

    // init sets 4 to 11 .................................................
    env.finit2 = new Abubu.Solver({
        fragmentShader : source( 'init2' ) ,
        targets : new OvvrTargets2( env.fcolors ) ,
    } ) ;
    env.sinit2 = new Abubu.Solver({
        fragmentShader : source( 'init2' ) ,
        targets : new OvvrTargets2( env.scolors ) ,
    } ) ;

    env.initStates = function(){
        env.finit1.render() ;
        env.finit2.render() ;

        env.sinit1.render() ;
        env.sinit2.render() ;
        return ;
    }

/*------------------------------------------------------------------------
 * Initiate all coeficients 
 *------------------------------------------------------------------------
 */
    env.running     = false ;
    env.skip        = 20 ;
    env.time        = 0. ;
    
    // model params
    env.dt          = 0.05 ;    /* time step size       */
    env.C_m         = 1. ;      /* cell conductance     */
    if (loadedJSON?.length){
        env.lx = loadedJSON.length/10 ;
    }else{
        env.lx = 8.  ;
    }
    env.diffCoef    = 1.e-3 ;   /* diffusion coeficient */
    env.modelFloats = ['dt' , 'C_m', 'diffCoef', 'lx' ] ;

    env.allFloats   = [...env.allFloats, ...env.modelFloats ] ; 
   
    // current multipliers ...............................................
    env.currentMultipliers = [
        'C_Na',     'C_Nafast',     'C_Nalate',     'C_NaCa',   
        'C_to',     'C_CaL',        'C_CaNa',       'C_CaK',        
        'C_Kr',     'C_Ks',         'C_K1',         'C_NaCai',      
        'C_NaCass', 'C_NaKNa',      'C_NaKK',       'C_NaK',    
        'C_Nab',    'C_Kb',         'C_Cab',        'C_pCa',    
        'C_relNP',  'C_relCaMK',    'C_upNP',       'C_upCaMK', 
        'C_leak',   'C_up',         'C_tr',         'C_rel',        
        'C_diffCa', 'C_diffNa',     'C_diffK'                       ] ;

    env.allFloats = [   ...env.allFloats, 
                        ...env.currentMultipliers ] ;
    
    // time multipliers ..................................................
    env.timeMultipliers = [
        'Ct_m',     'Ct_h',         'Ct_j',         'Ct_hCaMKslow', 
        'Ct_hslow', 'Ct_mL',        'Ct_jCaMK',     'Ct_hL', 
        'Ct_hLCaMK','Ct_a',         'Ct_ifast',     'Ct_islow', 
        'Ct_aCaMK', 'Ct_iCaMKfast', 'Ct_iCaMKslow', 'Ct_d',     
        'Ct_ffast', 'Ct_fslow',     'Ct_fCafast',   'Ct_fCaslow', 
        'Ct_jCa',   'Ct_fCaMKfast', 'Ct_fCaCaMKfast','Ct_n', 
        'Ct_xrfast','Ct_xrslow',    'Ct_xs1',       'Ct_xs2', 
        'Ct_xk1',   'Ct_relNP',     'Ct_relCaMK',   'Ct_tr', 
        'Ct_diffCa','Ct_diffNa',    'Ct_diffK',                     ] ;
    
    env.allFloats = [   ...env.allFloats, 
                        ...env.timeMultipliers ] ;

    // scaling factors ...................................................
    env.scalingFactors = [
        'SGNalate' , 'SGto' ,       'SPCa',         'SGKr'     ,
        'SGKs'     , 'SGK1' ,       'SGNaCa',       'SGNaK'    , 
        'SGKb'     , 'SJrel' ,      'SJup',         'SCMDN' ] ;

    env.allFloats = [   ...env.allFloats, 
                        ...env.scalingFactors ];

    env.cellType = 2 ; // default is endocardial cells
    env.allInts = [ ...env.allInts, 'cellType' ] ;

    // extra-cellular concentrations .....................................
    env.Na_o        = 140 ;         /* Sodium               */
    env.Ca_o        = 1.8 ;         /* Calcium              */ 
    env.K_o         = 5.4 ;         /* Potasium             */

    env.extraCellularConcentrations = [ 'Na_o', 'Ca_o', 'K_o' ] ;
    env.allFloats = [   ...env.allFloats , 
                        ...env.extraCellularConcentrations ];

    // all float uniforms that need to be initialized with ones ..........
    env.oneFloats = [
        ...env.currentMultipliers,  ...env.timeMultipliers,
        ...env.scalingFactors ] ;

    // initialize values to 1.0 ..........................................
    for(let i in env.oneFloats){
        let name = env.oneFloats[i] ;
        env[name] = 1. ;
    }

    // Common uniforms for comp1 & comp2 solvers .........................
    class CompUniforms{
        constructor( obj, floats, ints, txtrs){
            for(let i in floats ){
                let name    = floats[i] ;
                this[name]  = { type :'f', value : obj[name] } ;
            }
            for(let i in ints){
                let name    = ints[i] ;
                this[name]  = { type : 'i', value : obj[name] } ;
            }
            for(let name of txtrs){
                this[name] = { type : 't', value : obj[name] } ;
            }
        }
    }

    // uniforms for comp1 solvers ........................................
    class Comp1Uniforms extends CompUniforms{
        constructor( _fc, _sc ){
            super(env, env.allFloats, env.allInts, env.allTxtrs) ;
            for(let i=0; i<11 ; i++){
                this['icolor'+i] = { type : 't', value : _fc[i] } ;
            }   
        }
    }

    // uniforms for comp2 solvers ........................................
    class Comp2Uniforms extends CompUniforms{
        constructor( _fc, _sc ){
            super(env, env.allFloats, env.allInts, env.allTxtrs) ; 
            // colors already updated by comp1
            for(let i=0; i<4 ; i++){
                this['icolor'+i] = { type : 't', value : _sc[i] } ;
            }
            // other colors
            for(let i=4; i<11 ; i++){
                this['icolor'+i] = { type : 't', value : _fc[i] } ;
            }
        }
    } ;
/*------------------------------------------------------------------------
 * marching steps 
 *------------------------------------------------------------------------
 */
    // comp1 solvers .....................................................
    env.fcomp1 = new Abubu.Solver({
        fragmentShader : source('comp1') ,
        uniforms : new Comp1Uniforms( env.fcolors, env.scolors ) ,
        targets : new OvvrTargets1( env.scolors ) ,
    } ) ;
    env.scomp1 = new Abubu.Solver({
        fragmentShader : source('comp1') ,
        uniforms : new Comp1Uniforms( env.scolors, env.fcolors ) ,
        targets : new OvvrTargets1( env.fcolors ) ,
    } ) ;

    // comp2 solvers .....................................................
    env.fcomp2 = new Abubu.Solver({
        fragmentShader : source( 'comp2' ) ,
        uniforms : new Comp2Uniforms( env.fcolors, env.scolors ) ,
        targets : new OvvrTargets2( env.scolors ) ,
    } ) ;

    env.scomp2 = new Abubu.Solver({
        fragmentShader : source( 'comp2' ) ,
        uniforms : new Comp2Uniforms( env.scolors, env.fcolors ) ,
        targets : new OvvrTargets2( env.fcolors ) ,
    } ) ;

    env.comps = [ env.fcomp1, env.fcomp2, env.scomp1, env.scomp2 ] ;
    // marches the solution for two time steps ...........................
    env.march = function(){
        env.fcomp1.render() ;
        env.fcomp2.render() ;
        env.scomp1.render() ;
        env.scomp2.render() ;
        env.time += 2.*env.dt ;
    } ;


/*========================================================================
 * surfaceVisualizer 
 *========================================================================
 */
    env.deepv = new Abubu.DeepVoxelizer({
        canvas : canvas_1 ,
        input : env.fcolor4 ,
        structure : env.structure ,
        fovy : 0.51,
        rotation : [3.31,-3.14,2.29] ,
        lightDirection : [ 0.6,0.25,-2.06] ,
        lightSpecularTerm : 0.5, 
        lightAmbientTerm : 0.1, 
        materialSpecularTerm : 5.2 ,
        materialAmbientTerm : 0.1 ,
        shininess : 10 ,
        minValue : -40 ,
        maxValue : 30 ,
        noPasses                : 1. ,
        voxelSize               : 1.5 ,
        alpha                   : 1.0 ,
    } ) ;

/*========================================================================
 * signal plot 
 *========================================================================
 */
    // signal plot .......................................................
    env.signalplot = new Abubu.SignalPlot({
        noPltPoints : 1024,
        grid : 'on',
        nx : 5,
        ny : 12, 
        xticks : { mode: 'auto', unit : 'ms', font : '11pt Times'} ,
        yticks : { mode: 'auto', precision:1, unit : 'mv', font : '11pt Times'} ,
        canvas : env.canvas_2 
    } ) ;

    env.voltageSignal = env.signalplot.addSignal( env.fcolor4 ,{
        channel : 'r', 
        minValue : -90 ,
        maxValue : 30. ,
        color :[0.5,0.,0.] ,
        restValue : -86 ,
        visible : true ,
        linewidth : 3,
        timeWindow: 1000 ,
        probePosition : [0.5,0.5] ,
    }) ;

    env.display = function(){
        if(!env.running){
            env.clickCopy.render();
        }
        env.signalplot.render() ;
        env.deepv.render() ;
    }

    // wall Timer ........................................................
    env.wallTimer = new WallTimer() ;

    // solve or pause simulations ........................................
    env.solveOrPause = function(){
        env.running = !env.running ;
        env.wallTimer.paused = !env.running ;

        if (env.running){
            //env.colorplot.status.text = 'Running...' ;
        }else{
            //env.colorplot.status.text = 'Paused!' ;
        }
    } 

    // initialize the solution using the solvers .........................
    env.init = function(){
        env.time = 0 ;
        env.wallTimer.reset() ;
        env.signalplot.init(env.time) ;
        env.initStates() ; 
        return ;
    }
    env.init() ;
    
/*------------------------------------------------------------------------
 * click
 *------------------------------------------------------------------------
 */
    env.click = new Abubu.Solver({
        fragmentShader : source( 'click' ) ,
        uniforms : {
            icolor4 : { type : 't', value : env.fcolor4 } ,
            compressed3dCrdt : { type : 't', 
                value : env.structure.compressed3dCrdt            } ,
            projectedCoordinates : { type : 't', 
                value : env.deepv.projectedCoordinates  } ,
            clickPosition : { type : 'v2', value : [0.,0] } ,
            clickRadius     : { type : 'f', value : 0.1 } ,
        } ,
        targets : {
            ocolor4 : { location : 0 , target : env.scolor4 } ,
        }
    } ) ;

    env.clickCopy = new Abubu.Copy( env.scolor4, env.fcolor4 ) ;
    
    env.cmndClick = new Abubu.CommandClickListener(
        canvas_1 , (e) =>{
            env.deepv.projectCoordinates() ;
            env.click.uniforms.clickPosition.value = e.position ;
            env.click.render() ;
            env.clickCopy.render() ;
        } , { mousemove : true  } 
    ) ;

    env.cntrlClick = new Abubu.CtrlClickListener(
        canvas_1 , (e) =>{
            env.deepv.projectCoordinates() ;
            env.click.uniforms.clickPosition.value = e.position ;
            env.click.render() ;
            env.clickCopy.render() ;
        } , { mousemove : true  } 
    ) ;

    env.shiftClick = new Abubu.ShiftClickListener(
        canvas_1,
        (e)=>{
            env.deepv.projectCoordinates() ;
            var clickCompPosition = 
            env.deepv.getCompressedClickPosition(e.position);
            env.signalplot.setProbePosition( clickCompPosition ) ;
            env.signalplot.init(env.time) ;
        } ) ;        

/*------------------------------------------------------------------------
 * editors
 *------------------------------------------------------------------------
 */
    env.editor = new Abubu.Editor({
        sources : {
            direction : {
                source : source('directionator') ,
                solvers: [ env.directionator ],
                title : 'direction' ,
                filename: 'directionator.frag' ,
            } ,
            comp1 : { 
                source : source('comp1') , 
                solvers : [ env.fcomp1, env.scomp1 ] ,
                title : 'comp1' ,
                filename: 'comp1.frag' ,
            } ,
            comp2 : { 
                source : source('comp2') , 
                solvers : [ env.fcomp2, env.scomp2 ] ,
                title : 'comp2' ,
                filename: 'comp2.frag' ,
            } ,

            init1 : { 
                source : source('init1') , 
                solvers : [ env.finit1, env.sinit1 ] ,
                title : 'init1' ,
                filename: 'init1.frag' ,
            } ,
            init2 : { 
                source : source('init2') , 
                solvers : [ env.finit2, env.sinit2 ] ,
                title : 'init2' ,
                filename: 'init2.frag' ,
            } ,


        } ,
        id : 'editor', 
        active: 'comp1' ,
    } ) ;

    env.toggleEditor = function(){
        $("#editorSection").fadeToggle(300)
    } ;


/*------------------------------------------------------------------------
 * createGui
 *------------------------------------------------------------------------
 */
   createGui() ;

/*------------------------------------------------------------------------
 * rendering the program ;
 *------------------------------------------------------------------------
 */
    env.render = function(){
        if (env.running){
            for(let i=0; i<env.skip; i++){
                env.wallTimer.measure() ;
                env.march() ;
                env.signalplot.update(env.time) ;
            }
        }
        env.display() ;
        requestAnimationFrame(env.render) ;
    }

/*------------------------------------------------------------------------
 * add environment to document
 *------------------------------------------------------------------------
 */
    document.env = env ;

/*------------------------------------------------------------------------
 * render the webgl program
 *------------------------------------------------------------------------
 */
    env.render();

}/*  End of loadWebGL  */

/*========================================================================
 * add multiple parameters to the GUI
 *========================================================================
 */ 
function addToGui( 
        guiElemenent ,  // gui element to add options into
        obj,            // object that holds parameters
        paramList,      // array of strings that contains list 
                        // of parmeters to be added
        solverList      // array of solvers that need to be update upon 
                        // change of a parameter through gui interactions
    ){
    let elements = {} ;
    for(let param of paramList){
        elements[param] = 
            guiElemenent.add(obj, param ).onChange( ()=> {
                Abubu.setUniformInSolvers( 
                    param, obj[param], solverList ) ;
            } ) ;
    }
    return elements ;
}
/*========================================================================
 * addVectorToGui
 *========================================================================
 */
function addVectorToGui(
    guiElem, 
    obj, 
    param , opts){
    let elems = [] ;
    let labels = opts?.labels ?? 'XYZW' ;

    for (var i=0 ; i< obj[param].length ; i++){
        elems.push(guiElem.add( obj[param] , i.toString() )
            .name( param + ' ' + labels[i] ) );
       elems[i].onChange( ()=>{ obj[param] = obj[param] } ) ;
        if ( opts?.callback ){
            elems[i].onChange( ()=>{ 
                    obj[param] = obj[param];
                    opts.callback();
                }   ) ;
        }

        if ( opts?.min ){
            elems[i].min( opts.min ) ;
        }
        if ( opts?.max ){
            elems[i].max( opts.max ) ;
        }
        if ( opts?.step ){
            elems[i].step( opts.step ) ;
        }
         
    }
    return elems ;
}
/*========================================================================
 * createGui
 *========================================================================
 */
function createGui(){
    env.gui = new Abubu.Gui() ;
    env.gui.pnl1 = env.gui.addPanel({width:300}) ;
    let pnl1 = env.gui.pnl1 ;
    
    // model .............................................................
    pnl1.f0 = pnl1.addFolder('Model Info') ;
    let solvs = [ env.fcomp1, env.scomp1, env.fcomp2,env.scomp2 ] ;
    addToGui( pnl1.f0, env, env.modelFloats, solvs ) ;
    pnl1.f0_1 = pnl1.f0.addFolder( 'Current Multipliers'    ) ;
    pnl1.f0_2 = pnl1.f0.addFolder( 'Time Multipliers'       ) ;
    pnl1.f0_3 = pnl1.f0.addFolder( 'Scaling Factors'        ) ;
    pnl1.f0_4 = pnl1.f0.addFolder( 'Extra Cell. Concentrations'        ) ;

    addToGui( pnl1.f0_1, env, env.currentMultipliers, solvs ) ;
    addToGui( pnl1.f0_2, env, env.timeMultipliers, solvs ) ;
    addToGui( pnl1.f0_3, env, env.scalingFactors, solvs ) ;
    addToGui( pnl1.f0_4, env, env.extraCellularConcentrations, solvs ) ;

    // wall-time measurements --------------------------------------------
    pnl1.f4 = pnl1.addFolder('Wall time measurements') ;
    pnl1.f4.add(env.wallTimer, 'duration').name('Sim. Activity [ms]') ; 
    pnl1.f4.add(env.wallTimer, 'progress').name("Progress [%]").listen() ;
    pnl1.f4.add(env.wallTimer, 'lapsedTime').name("Measured Walltime [ms]").listen() ; 
    pnl1.f4.add(env.wallTimer, 'reset').name('Reset') ; 
    

    // display -----------------------------------------------------------
    pnl1.f1 = pnl1.addFolder('Display') ;
    pnl1.deepv = env.deepv.controlByGui( pnl1.f1) ;

    pnl1.f1.add(env, 'skip' ) ;
    pnl1.f1.open() ;
    
    // source code editors ...............................................
    pnl1.f2  = pnl1.addFolder('Edit/Save/Load Source Code') ;
    pnl1.f2.add( env , 'toggleEditor').name('Show/Hide Editor' ) ;
    pnl1.f2.add( env.editor , 'title', env.editor.titles )
        .name('Edit source').onChange( ()=>{ pnl1.updateDisplay() ;} ) ;
    pnl1.f2.add( env.editor , 'filename').name('Filename') ;
    pnl1.f2.add( env.editor , 'save' ).name('Save to file') ;
    pnl1.f2.add( env.editor , 'load' ).name('Load from file') ;

    // simulation ........................................................
    pnl1.f3 = pnl1.addFolder('Simulation') ;
    pnl1.f3.add(env, 'init' ).name('Initialize Solution') ;
    pnl1.f3.add(env, 'solveOrPause').name('Solve/Pause') ;
    pnl1.f3.add(env, 'time').name('Solution Time [ms]').listen() ;
    pnl1.f3.open() ;
    return ;
} /* End of createGui */
</script>


</body>
</html>

